---
title: "Test Simulation (AL, NV)"
author: '49595'
date: "2025-07-05"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r eval=FALSE}
library(tidyverse) ## NEED TO ADD OREGON TO THIS AND DELAWARE
library(dplyr)
library(readxl)
library(stringr)
library(ggplot2)
library(scales)
library(shiny)
library(osrm)
library(sf)
library(leaflet)
library(purrr)
library(rsconnect)
```

## Test Simulation using AL and NV
```{r test-simulation}
# 1. Load in data and perform preliminary cleaning
raw_abortion_births <- read_excel("../data_raw/County Abortion and Birth Counts 2009-2023.xlsx", range = cell_cols(c(1, 2, 3, 4, 5)))
raw_abortion_births <- raw_abortion_births[, 1:5]
raw_preg_fd <- read_excel("../data_raw/County Pregnancy and Fetal Loss Counts 2015-2023.xlsx")
raw_data_td <- read_excel("../data_raw/2025.04.01_abortionaccess_countyxmonth_CaitlinMyers.xlsx")

# Keep only origin county for travel distance data, as distance equates to closest abortion provider destination
raw_data_td <- raw_data_td %>% select(origin_fips_code, origin_county_name, year, month, distance_origintodest, dest_county_name, dest_lon, dest_lat)
raw_data_td <- raw_data_td %>%
  filter(month == 12) %>% select(-month)
raw_data_td <- raw_data_td %>%
  rename(fips_code = origin_fips_code) %>% rename(county_name = origin_county_name)
raw_data_td <- raw_data_td %>%
  filter(year >= 2015 & year <= 2023)

# Remove all state counties from abortion/birth dataset except AL, NV, ND
raw_abortion_births <- raw_abortion_births %>%
  filter(str_detect(county_name, "\\(NV\\)|\\(AL\\)|\\(PA\\)|\\(MI\\)|\\(OR\\)|\\(MO\\)"))

# Remove all state counties from pregnancy/fetal death dataset except AL, NV, ND
raw_preg_fd <- raw_preg_fd %>%
  filter(str_detect(county_name, "\\(NV\\)|\\(AL\\)|\\(PA\\)|\\(MI\\)|\\(OR\\)|\\(MO\\)"))

# 2. Merge the 3 datasets
merge1 <- merge(raw_data_td, raw_abortion_births, by=c("county_name", "year"))
merge1 <- merge1 %>% select(-fips_code.x) %>% rename(fips_code = fips_code.y)
merged_dataset <- merge(merge1, raw_preg_fd, by=c("fips_code", "county_name", "year"))
merged_dataset <- merged_dataset %>%
  mutate(
    pregnancies_total = as.numeric(pregnancies_total),
    abortions_total = as.numeric(abortions_total),
    births_total = as.numeric(births_total),
    fetal_deaths = as.numeric(fetal_deaths)
  )
merged_dataset[is.na(merged_dataset)] <- 0

# 3. Set up simulation function
simulate_self_managed <- function(df) {
  df %>%
    mutate(
      self_managed_abortions = pregnancies_total - abortions_total - births_total - fetal_deaths,
      post_dobbs = if_else(year >= 2022, 1, 0),
      total_resolved = abortions_total + self_managed_abortions + births_total + fetal_deaths,
      residual = pregnancies_total - total_resolved
    )
}

simulated_df <- simulate_self_managed(merged_dataset)
simulated_df <- simulated_df %>%
  mutate(state = str_extract(county_name, "(?<=\\()[A-Z]{2}(?=\\))")) %>%
  filter(state %in% c("AL", "NV", "PA", "MI", "MO", "OR"))
simulated_df <- simulated_df %>%
  mutate(
    origin_lat = as.numeric(origin_lat),
    origin_lon = as.numeric(origin_lon),
    dest_lat   = as.numeric(dest_lat),
    dest_lon   = as.numeric(dest_lon)
  )
simulated_df <- simulated_df %>%
  mutate(self_managed_abortions = if_else(self_managed_abortions < 0, 0, self_managed_abortions))
```



## Distance-Binned Mean Plot of Self-Managed Abortions
```{r distance-binned-mean-plot}
# Bin travel distances into ordinal categories
simulated_df_binned <- simulated_df %>%
  mutate(
    distance_bin = case_when(
      distance_origintodest < 25 ~ "<25 miles",
      distance_origintodest < 50 ~ "25–49 miles",
      distance_origintodest < 100 ~ "50–99 miles",
      distance_origintodest < 150 ~ "100–149 miles",
      TRUE ~ "150+ miles"
    )
  )

# Filter only for post-Dobbs years
sma_2022 <- simulated_df_binned %>% filter(year == 2022)
sma_2023 <- simulated_df_binned %>% filter(year == 2023)

# Plot for 2022
plot_2022 <- sma_2022 %>%
  group_by(distance_bin) %>%
  summarise(mean_sma = mean(self_managed_abortions, na.rm = TRUE),
            se_sma = sd(self_managed_abortions, na.rm = TRUE) / sqrt(n())) %>%
  ggplot(aes(x = distance_bin, y = mean_sma)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_errorbar(aes(ymin = mean_sma - se_sma, ymax = mean_sma + se_sma), width = 0.2) +
  labs(title = NULL,
       x = "Travel Distance to Nearest Provider", y = "Mean Estimated SMAs") +
  theme_minimal() +
  theme(
    plot.title = element_blank(),
    axis.title = element_text(face = "bold", color = "black", family = "Arial"),
    axis.text = element_text(color = "black", family = "Arial")
  )

# Save plot
ggsave(
  filename = "../Figures/distance_binned_2022.png",
  plot = plot_2022,
  width = 8,
  height = 5,
  dpi = 300
)

# Plot for 2023
plot_2023 <- sma_2023 %>%
  group_by(distance_bin) %>%
  summarise(mean_sma = mean(self_managed_abortions, na.rm = TRUE),
            se_sma = sd(self_managed_abortions, na.rm = TRUE) / sqrt(n())) %>%
  ggplot(aes(x = distance_bin, y = mean_sma)) +
  geom_bar(stat = "identity", fill = "darkgreen") +
  geom_errorbar(aes(ymin = mean_sma - se_sma, ymax = mean_sma + se_sma), width = 0.2) +
  labs(title = NULL,
       x = "Travel Distance to Nearest Provider", y = "Mean Estimated SMAs") +
  theme_minimal() +
  theme(
    plot.title = element_blank(),
    axis.title = element_text(face = "bold", color = "black", family = "Arial"),
    axis.text = element_text(color = "black", family = "Arial")
  )

# Save plot
ggsave(
  filename = "../Figures/distance_binned_2023.png",
  plot = plot_2023,
  width = 8,
  height = 5,
  dpi = 300
)
```



## Build the Test Simulation's Webpage Application
``` {r simulation-test-webpage}
library(shiny)
library(leaflet)
library(osrm)
library(dplyr)
library(sf)
library(tigris)
options(tigris_use_cache = TRUE)

# Read in data
simulated_df <- readRDS("simulated_df.rds")

### UI Component
ui <- fluidPage(
  titlePanel("Abortion Access Analysis"),
  sidebarLayout(
    sidebarPanel(
      selectInput(
        inputId = "state",
        label = "Select State:",
        choices = c("AL", "NV", "PA", "MI", "OR", "MO")
      ),
      selectizeInput(
        inputId = "county",
        label = "Origin County:",
        choices = NULL
      ),
      selectInput(
        inputId = "year",
        label = "Year:",
        choices = NULL
      ),
      actionButton("go", "Calculate Route", class = "btn-primary"),
      hr(),
      h4("Abortion Access Metrics:"),
      tableOutput("metricsTable")
    ),
    mainPanel(
      leafletOutput("routeMap", height = "600px"),
      h4("Route Details:"),
      verbatimTextOutput("routeDetails")
    )
  )
)

### Server Logic
server <- function(input, output, session) {
  
  # Set the public OSRM server once globally
  options(osrm.server = "https://router.project-osrm.org/", osrm.profile = "car")
  
  # Reactive: Load appropriate dataset based on selected state
  state_data <- reactive({
    req(input$state)
    simulated_df
  })
  
  observe({
    data <- state_data()
    updateSelectizeInput(
      session, 
      "county",
      choices = sort(unique(data$county_name)),
      selected = character(0)
    )
  })
  
  observe({
    data <- state_data()
    updateSelectInput(
      session,
      "year",
      choices = sort(unique(data$year)),
      selected = character(0)
    )
  })
  
  filtered_data <- reactive({
    req(input$county, input$year)
    
    state_data() %>%
      filter(county_name == input$county,
             year == input$year) %>%
      arrange(distance_origintodest) %>%
      slice(1)
  })
  
  route_data <- eventReactive(input$go, {
    data <- filtered_data()
    req(nrow(data) > 0)
    
    tryCatch({
      route <- osrmRoute(
        src = c(lon = data$origin_lon, lat = data$origin_lat),
        dst = c(lon = data$dest_lon, lat = data$dest_lat),
        overview = "full",
        returnclass = "sf"
      )
      
      # Attach metadata for use in outputs
      route$origin <- input$county
      route$destination <- data$dest_county_name
      route$driving_distance <- round(route$distance, 1)
      
      return(route)
    }, error = function(e) {
      showNotification(paste("Routing failed:", e$message), type = "error")
      return(NULL)
    })
  })
  
  output$routeMap <- renderLeaflet({
    if (input$state == "AL") {
      view <- list(lng = -86.9023, lat = 32.3182, zoom = 6)
    } else if (input$state == "NV") {
      view <- list(lng = -116.4194, lat = 38.8026, zoom = 6)
    } else if (input$state == "PA") {
      view <- list(lng = -101.0020, lat = 47.5515, zoom = 6)
    } else if (input$state == "MI"){
      view <- list(lng = -84.5068, lat = 44.1822, zoom = 6)
    } else if(input$state == "OR"){
      view <- list(lng = -120.5000, lat = 43.8041, zoom = 6)
    } else {
      view <- list(lng = -92.172851, lat = 38.57932, zoom = 6)
    }
    
    leaflet() %>%
      addProviderTiles(providers$CartoDB.Positron) %>%
      setView(lng = view$lng, lat = view$lat, zoom = view$zoom)
  })
  
  observeEvent(input$go, {
    tryCatch({
      data <- filtered_data()
      req(nrow(data) > 0)
      
      route <- route_data()
      req(!is.null(route))
      
      # Extract the snapped route start/end points
      route_coords <- st_coordinates(route$geometry)
      snapped_origin <- route_coords[1, ]
      snapped_dest <- route_coords[nrow(route_coords), ]
      
      # Define red and blue icons using awesomeIcons
      redIcon <- awesomeIcons(
        icon = 'circle',
        iconColor = 'white',
        markerColor = 'red',
        library = 'fa'
      )
      
      blueIcon <- awesomeIcons(
        icon = 'flag',
        iconColor = 'white',
        markerColor = 'blue',
        library = 'fa'
      )
      
      # Update the leaflet map
      leafletProxy("routeMap") %>%
        clearMarkers() %>%
        clearShapes() %>%
        
        # Add route polyline
        addPolylines(
          data = route,
          color = "#FF6B6B",
          weight = 4,
          label = paste("Driving distance:", route$driving_distance, "miles")
        ) %>%
        
        # Add origin marker at snapped location
        addAwesomeMarkers(
          lng = snapped_origin["X"],
          lat = snapped_origin["Y"],
          icon = redIcon,
          label = paste("Origin:", input$county)
        ) %>%
        
        # Add destination marker at snapped location
        addAwesomeMarkers(
          lng = snapped_dest["X"],
          lat = snapped_dest["Y"],
          icon = blueIcon,
          label = paste("Destination:", data$dest_county_name)
        ) %>%
        
        # Optional: diagnostic green dots
        addCircleMarkers(
          lng = c(snapped_origin["X"], snapped_dest["X"]),
          lat = c(snapped_origin["Y"], snapped_dest["Y"]),
          radius = 4,
          color = "green",
          fillColor = "green",
          fillOpacity = 1
        )
      
    }, error = function(e) {
      showNotification(paste("Map update failed:", e$message), type = "error")
    })
  })
  
  output$routeDetails <- renderPrint({
    route <- route_data()
    req(route)
    
    cat(
      "Origin: ", route$origin, "\n",
      "Destination: ", route$destination, "\n",
      "Driving Distance to Nearest Abortion Provider: ", route$driving_distance, " miles"
    )
  })
  
  output$metricsTable <- renderTable({
    data <- filtered_data()
    req(nrow(data) > 0)
    
    data.frame(
      Metric = c("Pregnancies", "Clinical Abortions", "Self-Managed Abortions", "Fetal Deaths"),
      Count = c(
        data$births_total,
        data$abortions_total,
        data$self_managed_abortions,
        data$fetal_deaths
      )
    )
  }, striped = TRUE)
}


shinyApp(ui = ui, server = server)

```


